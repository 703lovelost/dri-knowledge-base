# Я проснулся и открыл Logisim

## Дальше день может стать только хуже

Вообще это апогей моего безумия. По сути я переписал данные с справочника, но с микроприколами. Но в своё оправдание скажу, что некоторые описания на сайте — полная хуйня. А теперь к библиотекам.

## Проводка

Это так сказать основа, база. Библиотека, чьи элементы крайне просты и функциональны. Начнём по порядку:

### <a name="splitter"></a>Разветвитель
    
В разветвителе твоя сила и мудрость. Это инструмент, способный делать очень много вещей. На вход принимает некое n-битное число и возвращает какое-то количество m-битных чисел. Главное помнить, что у разветвителя нет строго определённого «входа» и «выхода» и что он может делить число не только на отдельные биты.
    
### <a name="pin"></a>Контакт
    
Вещь, без которой схемы не имели бы смысла. С ним всё просто: может быть входным/выходным, иметь два/три состояния.
    
### <a name="probe"></a>Датчик
    
Показывает значение, которое пердаёт провод в одной из нескольких систем счисления.
    
### <a name="tunnel"></a>Тоннель
    
Пожалуй самый используемый элемент в больших проектах. Позволяет передавать значения из одного места в другое без использования проводов. Обычно при работе с тоннелями имеется один "входной" и некоторое количество "выходных" тоннелей.
    
### <a name="pull"></a>Согласующий резистор
    
Подтягивает бит равный X к 0/1/error, не влияет на остальные значения.
    
### <a name="clock"></a>Тактовый генератор
    
Меняет значения 0/1 раз в n-ое количество тактов. О нём пока что забудем.
    
### <a name="const"></a>Константа/питание/земля
    
Всё это обычные константы, но на значения земли и питания повлиять нельзя. Значение земли всегда 0, а питания — n^2-1 (0b1…1), где n — количество битов.
    
### <a name="transist"></a>Транзистор
    
Хуета. У вас будет 3 задания на транзисторы и скорее всего это будет единственный раз, когда вы их используете, но так как это гайд, то я и про них расскажу. У транзистора есть сток, исток и затвор, а также тип — n или p. 
    
- p-тип выдаёт на истоке значение стока, если на затворе 0, иначе выдаёт X.
- n-тип выдаёт на истоке значение стока, если на затворе 1, иначе выдаёт X.
    
При подаче на затвор X оба типа транзисторов выдадут error.
    
### <a name="transmis"></a>Передаточный вентиль
    
Задумывался как модуль, повторяющий поведение сочетания n и p транзисторов, но что-то пошло не так. Поделим данный блок на сток, исток и n-затвор и p-затвор. Если значения на затворах одинаковые, то на истоке ошибка. Когда на n-затворе 1, а на p-затворе 0 на истоке значение стока, иначе на истоке X. 
    
### <a name="extender"></a>Расширитель битов
    
Увеличивает или уменьшает количество бит в числе. Имеет 4 типа расширения:
    
1. Ноль — все новые биты равны нулю.
2. Единица — все новые биты равны единице.
3. Знак — все новые биты равны биту знака.
4. Вход — все новые биты равны биту, который подан на вход. 

## Элементы

Тут расписывать практически нечего. Это библиотека содержащая логические функции и кое-что ещё.

### <a name="buffer"></a>Буфер
    
Бесполезен чуть менее, чем полностью (поговаривают, может служить гарантией направления передаваемого значения, но мне это ни разу не понадобилось).
    
### <a name="xor"></a>Исключающее ИЛИ
    
Обычный xor, но есть нюанс. На выходе будет единица, только когда на входе одна единица, а остальные значения равны нулю.
    
### <a name="xnor"></a>Исключающее ИЛИ-НЕ
    
Эквивалентность с нюансом. Выдаёт один на выходе, если есть хотя бы 2 входа, на которые пришла единица, или все значения на входе равны 0. 
    
### <a name="even-odd"></a>Чётность/нечётность
    
Определяют будет ли сумма входных данных чётной или нечётной. Ещё их можно использовать как адекватное исключающее или/эквивалентность.
    
### <a name="controlled"></a>Управляемый буфер
    
Выдаёт значение на входе, если на управляющий вход пришла единица, иначе выдаёт X.
    

## Плексоры

Эта библиотека просто имба.

### <a name="mux"></a>Мультиплексор
    
Выдаёт значение с одного из входов в зависимости от того, какое число пришло выбирающий вход.
    
### <a name="demux"></a>Демультиплексор
    
Выдаёт значение с одного из выходов в зависимости от того, какое число пришло выбирающий вход.
    
### <a name="decoder"></a>Декодер
    
Демультиплексор, который на выходе всегда имеет единицу.
    
### <a name="priencod"></a>Шифратор приоритетов
    
На выход посылается наибольший порядковый номер входа, на который пришёл сигнал. 
    
### <a name="selector"></a>Селектор битов
    
Разделяет все биты в числе на группы по n-битов, а на выходе выводит группу под номером, указанном на выбирающем входе (все биты, выходящие за пределы изначального числа равны нулю).
    

## Арифметика

Тут всё очень кратко, потому что библиотека очень простая.

### <a name="mult-div"></a>Множитель/делитель
    
Тут всё очевидно, просто сообщу, что господин Иртегов запрещает использовать их в проектах, так как они сильно грузят систему.
    
### <a name="shifter"></a>Сдвигатель
    
Сдвигает число на определённой количество позиций (разрядность числа сдвига равна n, где 2^n — ближайшее число большее или равное, чем количество бит сдвигаемого числа).
    
Есть 3 основных вида сдвига:
    
1. Логический — новый бит числа всегда равен 0
2. Арифметический — значения заполняются самым левым битом в числе
3. Циклический — значения будто движутся по кругу (хотя в моей версии Logisim на месте правого сдвига находился “Логический правый”, но работает как циклический правый)

### <a name="bitfinder"></a>Искатель битов
    
Способен найти порядковый номер старшего 0/1 или младшего 0/1.
    

## Память

А теперь к веселому.  Эта библиотека должна пробудить в вас память предков, ведь иначе отроку юному не осилить её. Так что сейчас я вам о ней поведаю. 

Почти все компоненты в данной библиотеке имеют несколько отличительных входов:

1. Тактовый вход. Да-да, наконец-то нашлось применение тактовому генератору из первой библиотеки. По сути тактовый генератор говорит лишь о том, что компонент должен что-то сделать с выходными данными, а вот в какой момент он это будет делать диктуется фронтом. Существует 4 типа фронтов:
    - Передний фронт — компонент обновляет значение, когда значение тактового входа меняется с 0 на 1.
    - Задний фронт — компонент обновляет значение, когда значение тактового входа меняется с 1 на 0.
    - Высокий уровень — компонент обновляет значение, когда значение тактового входа 1.
    - Низкий уровень — компонент обновляет значение, когда значение тактового входа 1.
2. Вход выключения компонента — позволяет “выключить” тактовый вход для компонента.
3. Вход очистки — очищает память компонента, но делает это мгновенно (предположительно с частотой процессора), поэтому его следует использовать с осторожностью.


### <a name="flipflops"></a>Триггеры
    
По сути своей однобитный регистр, но в котором значение, которое хранит триггер (далее Q), меняется особым образом. А ещё он имеет вход, который асинхронно фиксирует значение на единице, и выход, который выдаёт противоположное Q значение.

1. D триггер — просто меняет Q на входное значение.
2. T триггер — если на вход подаётся 1, то меняет Q на противоположное значение, иначе не делает ничего.
3. J-K триггер — если значения J и K 
    1. оба равны 0, то Q не меняется 
    2. если оба равны 1, то Q становится обратным
    3. если J  равно 1, то Q равно 1
    4. если K равно 1, то Q равно 0
4. S-R триггер — аналогичен работе J-K триггера, но если S и R равны единице, то значение неопределtнно (в Logisim оно не будет меняться). Ещё, как и D триггер, имеет в качестве паттерна срабатывания Высокий и Низкий уровни, помимо Переднего и Заднего фронтов.

### <a name="register"></a>Регистр
    
Самый простой блок памяти. Просто хранит одно значение.
    
### <a name="counter"></a>Счётчик
    
Считает. А вообще каждый такт прибавляет или отнимает единицу от хранящегося внутри числа (можно отнимать или прибавлять большие числа, но понадобиться немного повозиться). Одним из параметров счётчика является максимальное число (при его достижении счётчик подаёт сигнал на выход переноса), что будет делать счётчик при его достижении определяется параметром Действие при переполнении. Есть 4 варианта:

1. Закольцовывать — счёт начнётся с 0/максимального значения.
2. Оставаться на значении
3. Продолжать счёт
4. Загрузить следующее значение — берёт значение с входа D.

### <a name="shiftreg"></a>Сдвиговый регистр
    
Долгое время не хотел пользоваться данным модулем, а зря. Модуль имеет два режима:

1. Параллельная загрузка — по сути своей модуль является очередью (да-да, этой недоструктурой). Добавляем мы значение в конец очереди, а берём значения из её начала. Каждое срабатывание тактового входа обеспечивает продвижение очереди. При параллельной загрузке доступны не только данные о каждом значении в очереди, но и быстрое их изменение. В этом случае элемент имеет вход для сдвига и вход для загрузки, последний имеет больший приоритет.
2. Последовательная загрузка — по сути то же самое, но теперь без всяких преимуществ, зато с сокрытием (почти со смыслом), правда, в основном от тебя самого. Модуль будет работать, только если на вход для сдвига подаётся единица (или ничего). И да, чтобы увидеть значения, которые ты записывал в очередь придется дождаться, когда они дойдут до её конца, ведь изначально очередь забита нулями.

### <a name="random"></a>Генератор случайных чисел
    
Генерирует случайное число (ахуеть) в зависимости от сида. 
    
### <a name="ram"></a>ОЗУ
    
Пишут, что это самый сложный компонент в Logisim, но в нём нет ничего особенного. Имеет три режима работы:

1. Один синхронный порт чтения/записи — данные на чтение/запись проходят через один выход, будет это чтение или запись определяется по входу ld (0 — запись, 1 — чтение). Значение будет записано, когда тактовый генератор сменит 0 на 1. Для работы с данным вариантом ОЗУ требуется использование управляемого буфера.
2. Один асинхронный порт чтения/записи — то же, что и прошлый вариант, но значения записываются мгновенно, из-за отсутствия тактового входа.
3. Раздельные порты чтения и записи — думаю, что по названию всё понятно. Наверное, это весьма удобный вариант работы с ОЗУ. Из необычного — порт ld теперь не отвечает за запись новых значение в ОЗУ (теперь для этого используется str), вместо этого он выключает выходные данные (вместо них будут идти xx…x).

### <a name="rom"></a>ПЗУ
    
Просто хранит некоторое количество значений.

## Ввод/вывод

Одна из самых простых библиотек, но между тем именно она является краеугольным камнем в вашем проекте.

### <a name="button"></a>Кнопка
    
Скорее всего будет использоваться вами для запуска/постановки на паузу/рестарта игры. По сути кнопка выдаёт одиночный сигнал, который будет идти, пока кнопка нажата (это создаёт проблемы), поэтому использовать её для чего-то большего не рекомендуется.
    
### <a name="joystick"></a>Джойстик
    
Очень спорная штука, так как максимальная разрядность 5 бит. Но с ним можно работать, хотя я бы не стал.
    
### <a name="keyboard"></a>Клавиатура
    
База. Позволяет воспроизвести стандартное управление на wasd и много чего ещё. При нажатии на инструмент транслирует символы ASCII в 7-битный код.
    
### <a name="led"></a>Светодиод
    
Это просто светодиод. Включает в себя 2 цвета. Не сильно удобен для визуальной части, но может быть неплохим индикатором процессов (стоит игра на паузе или нет и т.п.).
    
### <a name="7seg"></a>7-сегментный индикатор
    
Не особо понимаю зачем он нужен, но с его помощью можно изобразить буквы латинского алфавита (хотя бы часть из них).
    
### <a name="hexdig"></a>Шестнадцатеричный индикатор
    
Практически то же, что и прошлый вариант, только работать с ним проще.
    
### <a name="dotmat"></a>Светодиодная матрица
    
Именно она является базой для визуализации игры. Бывают трёх видов:

1. Столбцы 
2. Строки
3. Выбор Строки/Столбцы — особое извращение. По сути картина на матрице получается перемножением вертикальной матрицы (нижний вход) на горизонтальную (верхний вход), но есть нюанс — цифры на верхнем входе идут в противоположном порядке.

### <a name="tty"></a>Терминал
    
Выводит значения, поданные на вход, интерпретируя их как символы ASCII.
    
На этом описание библиотек заканчивается.